# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: import_circular_dependency.proto, root.proto
# plugin: python-betterproto2
# This file has been @generated

__all__ = (
    "RootPackageMessage",
    "Test",
)


import betterproto2
from pydantic.dataclasses import dataclass

from ..message_pool import default_message_pool

betterproto2.check_compiler_version("0.5.1")


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class RootPackageMessage(betterproto2.Message):
    pass


default_message_pool.register_message("import_circular_dependency", "RootPackageMessage", RootPackageMessage)


@dataclass(eq=False, repr=False, config={"extra": "forbid"})
class Test(betterproto2.Message):
    """
    This test-case verifies support for circular dependencies in the generated python files.

    This is important because we generate 1 python file/module per package, rather than 1 file per proto file.

    Scenario:

        The proto messages depend on each other in a non-circular way:

              Test -------> RootPackageMessage <--------------.
                `------------------------------------> OtherPackageMessage

        Test and RootPackageMessage are in different files, but belong to the same package (root):

              (Test -------> RootPackageMessage) <------------.
                `------------------------------------> OtherPackageMessage

        After grouping the packages into single files or modules, a circular dependency is created:

              (root: Test & RootPackageMessage) <-------> (other: OtherPackageMessage)
    """

    message: "RootPackageMessage | None" = betterproto2.field(1, betterproto2.TYPE_MESSAGE, optional=True)

    other_value: "other.OtherPackageMessage | None" = betterproto2.field(2, betterproto2.TYPE_MESSAGE, optional=True)


default_message_pool.register_message("import_circular_dependency", "Test", Test)


from . import other
